require_relative "generator"
require_relative "fields_table_generator"
require_relative "options_example_generator"
require_relative "options_table_generator"
require_relative "sections_generator"

class SinkGenerator < Generator
  ROOT_PATH = "../../../"

  attr_reader :options_example_generator,
    :options_table_generator,
    :sections_generator,
    :sink

  def initialize(sink, guides)
    super(guides)

    options = sink.options.to_h.values.sort
    @options_example_generator = OptionsExampleGenerator.new(options)
    @options_table_generator = OptionsTableGenerator.new(options, sink.sections)
    @sections_generator = SectionsGenerator.new(sink.sections)
    @sink = sink
  end

  def generate
    content = <<~EOF
      ---
      description: #{plural_write_verb.humanize} #{sink.input_types.to_sentence} events to #{remove_regex_links(sink.write_to_description)}
      ---

      <!---
      !!!WARNING!!!!

      This file is autogenerated! Please do not manually edit this file.
      Instead, please modify the contents of `dist/config/schema.toml`.
      -->

      # #{sink.name} sink

      ![](#{sink.diagram})

      #{beta(sink)}
      The `#{sink.name}` sink #{write_verb.pluralize} #{event_type_links(sink.input_types)} events to #{sink.write_to_description}.

      ## Example

      {% code-tabs %}
      {% code-tabs-item title="vector.toml (examples)" %}
      ```coffeescript
      #{options_example_generator.generate("sources.my_#{sink.name}_sink", :examples)}
      ```
      {% endcode-tabs-item %}
      {% code-tabs-item title="vector.toml (schema)" %}
      ```coffeescript
      #{options_example_generator.generate("sink.<sink-id>", :schema)}
      ```
      {% endcode-tabs-item %}
      {% endcode-tabs %}

      ## Options

      #{options_table_generator.generate}

      ## Input

      The `#{sink.name}` sink accepts #{event_type_links(sink.input_types)} events.

      ## Output

      #{output}

      ## Delivery Guarantee

      #{delivery_guarantee}
      
      #{guides_section(sink)}

      ## How It Works

      #{sections_generator.generate}

      #{troubleshooting(sink)}
      
      #{resources(sink)}
    EOF
    content
  end

  private
    def delivery_guarantee
      content =
        case sink.delivery_guarantee
        when "at_least_once"
          <<~EOF
          The `#{sink.name}` sinks offers an at least once delivery guarantee if your
          [pipeline is configured to achieve this][at_least_once_delivery].
          EOF

        when "best_effort"
          <<~EOF
          Due to nature of writing data to #{sink.write_to_description}, the `#{sink.name}` sink
          makes a [best effort delivery guarantee][best_effort_delivery].
          EOF
        else
          raise("Unsupported delivery_guarantee: #{sink.delivery_guarantee}")
        end

      content.strip
    end

    def output
      content =
        if sink.batching?
          <<~EOF
          The #{component_name(sink)} batches events up to the `batch_size` or `batch_timeout` options. When flushed, Vector will write to #{sink.write_to_description}. The encoding is dictated by the `encoding` option. Below is a templated example:

          #{sink.output}
          EOF
        else
          <<~EOF
          The #{component_name(sink)} streams events to #{sink.write_to_description}. The encoding of each event is dictated by the `encoding` option.

          #{sink.output}
          EOF
        end

      content.strip
    end

    def plural_write_verb
      case sink.write_style
      when "batching"
        "batches and flushes"
      when "streaming"
        "streams"
      else
        raise("Unknown write_style: #{sink.write_style.inspect}")
      end
    end

    def write_verb
      case sink.write_style
      when "batching"
        "batch and flush"
      when "streaming"
        "stream"
      else
        raise("Unknown write_style: #{sink.write_style.inspect}")
      end
    end
end