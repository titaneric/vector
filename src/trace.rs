use std::{
    marker::PhantomData,
    str::FromStr,
    sync::{Mutex, MutexGuard},
};

use metrics_tracing_context::MetricsLayer;
use once_cell::sync::OnceCell;
use tokio::sync::broadcast::{self, Receiver, Sender};
use tracing::{span::Span, Subscriber};
pub use tracing_futures::Instrument;
use tracing_limit::RateLimitedLayer;
use tracing_subscriber::{
    layer::{Context, SubscriberExt},
    util::SubscriberInitExt,
    Layer,
};
pub use tracing_tower::{InstrumentableService, InstrumentedService};

use crate::event::LogEvent;

/// BUFFER contains all of the internal log events generated by Vector
/// before the topology has been initialized. It will be cleared (set to
/// `None`) by the topology initialization routines.
static BUFFER: OnceCell<Mutex<Option<Vec<LogEvent>>>> = OnceCell::new();

/// SENDER holds the sender/receiver handle that will receive a copy of
/// all the internal log events *after* the topology has been
/// initialized.
static SENDER: OnceCell<Sender<LogEvent>> = OnceCell::new();

fn metrics_layer_enabled() -> bool {
    !matches!(std::env::var("DISABLE_INTERNAL_METRICS_TRACING_INTEGRATION"), Ok(x) if x == "true")
}

pub fn init(color: bool, json: bool, levels: &str) {
    let _ = BUFFER.set(Mutex::new(Some(Vec::new())));
    let fmt_filter = tracing_subscriber::filter::Targets::from_str(levels).expect(
        "logging filter targets were not formatted correctly or did not specify a valid level",
    );

    let metrics_layer = metrics_layer_enabled()
        .then(|| MetricsLayer::new().with_filter(tracing_subscriber::filter::LevelFilter::INFO));

    let subscriber = tracing_subscriber::registry()
        .with(metrics_layer)
        .with(BroadcastLayer::new().with_filter(fmt_filter.clone()));

    #[cfg(feature = "tokio-console")]
    let subscriber = {
        let console_layer = console_subscriber::ConsoleLayer::builder()
            .with_default_env()
            .spawn();

        subscriber.with(console_layer)
    };

    if json {
        let formatter = tracing_subscriber::fmt::layer().json().flatten_event(true);

        #[cfg(test)]
        let formatter = formatter.with_test_writer();

        let rate_limited = RateLimitedLayer::new(formatter);
        let subscriber = subscriber.with(rate_limited.with_filter(fmt_filter));

        let _ = subscriber.try_init();
    } else {
        let formatter = tracing_subscriber::fmt::layer()
            .with_ansi(color)
            .with_writer(std::io::stderr);

        #[cfg(test)]
        let formatter = formatter.with_test_writer();

        let rate_limited = RateLimitedLayer::new(formatter);
        let subscriber = subscriber.with(rate_limited.with_filter(fmt_filter));

        let _ = subscriber.try_init();
    }
}

#[cfg(test)]
pub fn reset_early_buffer() {
    *early_buffer() = Some(Vec::new());
}

fn early_buffer() -> MutexGuard<'static, Option<Vec<LogEvent>>> {
    BUFFER
        .get()
        .expect("Internal logs buffer not initialized")
        .lock()
        .expect("Couldn't acquire lock on internal logs buffer")
}

pub fn stop_buffering() {
    *early_buffer() = None;
}

/// Gets the current [`Span`].
pub fn current_span() -> Span {
    Span::current()
}

pub struct TraceSubscription {
    pub buffer: Vec<LogEvent>,
    pub receiver: Receiver<LogEvent>,
}

pub fn subscribe() -> TraceSubscription {
    let buffer = match early_buffer().as_mut() {
        Some(buffer) => buffer.drain(..).collect(),
        None => Vec::new(),
    };
    let receiver = SENDER.get_or_init(|| broadcast::channel(99).0).subscribe();
    TraceSubscription { buffer, receiver }
}

struct BroadcastLayer<S> {
    _subscriber: PhantomData<S>,
}

impl<S> BroadcastLayer<S> {
    const fn new() -> Self {
        BroadcastLayer {
            _subscriber: PhantomData,
        }
    }
}

impl<S> Layer<S> for BroadcastLayer<S>
where
    S: Subscriber + 'static,
{
    fn on_event(&self, event: &tracing::Event<'_>, _ctx: Context<'_, S>) {
        if let Some(buffer) = early_buffer().as_mut() {
            buffer.push(event.into());
        }
        if let Some(sender) = SENDER.get() {
            let _ = sender.send(event.into());
        }
    }
}
